:PROPERTIES:
:GPTEL_MODEL: gpt-4o
:GPTEL_BACKEND: ChatGPT
:GPTEL_SYSTEM: \n     You are a helpful assistant, occasionally dwelling within Emacs, believe it or not.\n     A convivial sort with an easy-going natural manner.\n     Wrap any generated code in gfm code blocks - this applies only to code, not to general responses.  For example\n     ```emacs-lisp\n     (message "this is a test")\n     ```\n
:GPTEL_BOUNDS: ((1787 . 4298) (4418 . 7514) (7713 . 9627) (9664 . 11391) (11392 . 11902) (11952 . 13910) (13963 . 16431) (16481 . 16558) (16606 . 16634) (16671 . 16707) (16710 . 19367) (19525 . 21272) (21273 . 22488) (22529 . 23957) (23962 . 24177) (24182 . 25299) (25317 . 25325) (25331 . 26822) (26859 . 26899) (26901 . 27777))
:END:
** List of frameworks
*** Criterion (2k stars) (last release: 2.4.2 May 13 - 2023)
https://github.com/Snaipe/Criterion
https://criterion.readthedocs.io/en/latest/
*** Unity (Throw the switch) (3.9k stars) (last release: 2.6.0 March 10 - 2024)
https://www.throwtheswitch.org/tools
https://github.com/ThrowTheSwitch/Unity
https://github.com/ThrowTheSwitch/Unity/blob/master/docs/UnityGettingStartedGuide.md
https://www.throwtheswitch.org/
*** munit (554 stars)
https://nemequ.github.io/munit/
*** Cmocka
https://cmocka.org/
https://gitlab.com/cmocka/cmocka
*** Check (1.1k stars last release: 0.15.2 Aug 9 - 2020)
https://libcheck.github.io/check/
https://github.com/libcheck/check
- cross-platform
*** AceUnit (last update: 2015)
https://aceunit.sourceforge.net/
https://sourceforge.net/projects/aceunit/
- either dead or finished
*** CUnit (last update: 2015)
https://sourceforge.net/projects/cunit/
*** CuTest (last update: 2018)
https://cutest.sourceforge.net/
- highly portable
** Chat
*** which testing frameworks for C and C++ do you know?

There are several popular testing frameworks for C and C++ that you might find useful. Here are a few:

1. *Google Test (gtest)*: A widely-used C++ testing framework developed by Google.

   #+begin_src cpp
   #include <gtest/gtest.h>

   TEST(SampleTest, AssertionTrue) {
     EXPECT_EQ(1, 1);
   }

   int main(int argc, char **argv) {
     ::testing::InitGoogleTest(&argc, argv);
     return RUN_ALL_TESTS();
   }
   #+end_src

2. *Catch2*: A versatile testing framework for C++.

   #+begin_src cpp
   #define CATCH_CONFIG_MAIN
   #include "catch.hpp"

   TEST_CASE("Sample test", "[example]") {
     REQUIRE(1 == 1);
   }
   #+end_src

3. *CppUnit*: A port of the JUnit framework to C++.

   #+begin_src cpp
   #include <cppunit/TestCase.h>
   #include <cppunit/extensions/HelperMacros.h>
   #include <cppunit/ui/text/TestRunner.h>

   class SampleTest : public CppUnit::TestCase {
     CPPUNIT_TEST_SUITE(SampleTest);
     CPPUNIT_TEST(testAssertion);
     CPPUNIT_TEST_SUITE_END();

   public:
     void testAssertion() {
       CPPUNIT_ASSERT(1 == 1);
     }
   };

   CPPUNIT_TEST_SUITE_REGISTRATION(SampleTest);

   int main() {
     CppUnit::TextUi::TestRunner runner;
     runner.addTest(SampleTest::suite());
     runner.run();
     return 0;
   }
   #+end_src

4. *Boost.Test*: Part of the Boost libraries, useful if you're already using Boost in your project.

   #+begin_src cpp
   #define BOOST_TEST_MODULE SampleTest
   #include <boost/test/included/unit_test.hpp>

   BOOST_AUTO_TEST_CASE(SampleTestCase) {
     BOOST_CHECK_EQUAL(1, 1);
   }
   #+end_src

5. *Unity*: A lightweight C testing framework.

   #+begin_src c
   #include "unity.h"

   void setUp(void) {}
   void tearDown(void) {}

   void test_SampleTest(void) {
     TEST_ASSERT_EQUAL(1, 1);
   }

   int main(void) {
     UNITY_BEGIN();
     RUN_TEST(test_SampleTest);
     return UNITY_END();
   }
   #+end_src

6. *CMocka*: A lightweight and easy-to-use C unit testing framework.

   #+begin_src c
   #include <stdarg.h>
   #include <stddef.h>
   #include <setjmp.h>
   #include <cmocka.h>

   static void sample_test(void **state) {
     assert_int_equal(1, 1);
   }

   int main(void) {
     const struct CMUnitTest tests[] = {
       cmocka_unit_test(sample_test),
     };
     return cmocka_run_group_tests(tests, NULL, NULL);
   }
   #+end_src

Each of these frameworks has its own strengths and use cases. The best one for you will depend on your project's specific requirements and your personal or team's preferences.

*** For now I'am working on C projects, notably I compile with "cc". Can we tighten our search on C test-frameworks?

Absolutely! Focusing on C-specific test frameworks, here are some of the popular choices:

1. *Unity*: A lightweight and portable unit testing framework for C.

   #+begin_src c
   #include "unity.h"

   void setUp(void) {
       // Code to set up before each test
   }

   void tearDown(void) {
       // Code to clean up after each test
   }

   void test_SampleTest(void) {
       TEST_ASSERT_EQUAL(1, 1);
   }

   int main(void) {
       UNITY_BEGIN();
       RUN_TEST(test_SampleTest);
       return UNITY_END();
   }
   #+end_src

2. *CMocka*: An easy-to-use unit testing framework for C with a very simple API.

   #+begin_src c
   #include <stdarg.h>
   #include <stddef.h>
   #include <setjmp.h>
   #include <cmocka.h>

   static void sample_test(void **state) {
       assert_int_equal(1, 1);
   }

   int main(void) {
       const struct CMUnitTest tests[] = {
           cmocka_unit_test(sample_test),
       };
       return cmocka_run_group_tests(tests, NULL, NULL);
   }
   #+end_src

3. *Check*: A unit testing framework for C programs that features a simple interface.

   #+begin_src c
   #include <check.h>

   START_TEST(sample_test) {
       ck_assert_int_eq(1, 1);
   }
   END_TEST

   Suite* sample_suite(void) {
       Suite *s;
       TCase *tc_core;

       s = suite_create("Sample");
       tc_core = tcase_create("Core");

       tcase_add_test(tc_core, sample_test);
       suite_add_tcase(s, tc_core);

       return s;
   }

   int main(void) {
       int number_failed;
       Suite *s;
       SRunner *sr;

       s = sample_suite();
       sr = srunner_create(s);

       srunner_run_all(sr, CK_NORMAL);
       number_failed = srunner_ntests_failed(sr);
       srunner_free(sr);

       return (number_failed == 0) ? 0 : 1;
   }
   #+end_src

4. *Criterion*: A cross-platform C unit testing framework which aims to be easy to use.

   #+begin_src c
   #include <criterion/criterion.h>

   Test(sample, sample_test) {
       cr_assert_eq(1, 1, "1 should be equal to 1");
   }
   #+end_src

5. *CuTest*: A simple framework for writing, organizing, and running C unit tests.

   #+begin_src c
   #include <stdio.h>
   #include "CuTest.h"

   void SampleTest(CuTest *tc) {
       CuAssertIntEquals(tc, 1, 1);
   }

   CuSuite* SampleGetSuite(void) {
       CuSuite* suite = CuSuiteNew();
       SUITE_ADD_TEST(suite, SampleTest);
       return suite;
   }

   void RunAllTests(void) {
       CuString *output = CuStringNew();
       CuSuite* suite = CuSuiteNew();

       CuSuiteAddSuite(suite, SampleGetSuite());
       CuSuiteRun(suite);

       CuSuiteSummary(suite, output);
       CuSuiteDetails(suite, output);
       printf("%s\n", output->buffer);
   }

   int main(void) {
       RunAllTests();
       return 0;
   }
   #+end_src

All the listed frameworks are designed to be easy to integrate and to provide powerful testing capabilities for C projects. Each one has its own advantages. For example, Unity is highly portable, while CMocka provides mock capabilities, and Check offers a more extensive feature set. Choose the one that best fits your needs!

*** I probably don't need mocks for the beginning. I would like it to be easy, but also a good starting point from where I can expand my tests, maybe later switching to a more powerful framework.

Given your requirements, I'd recommend starting with either /Unity/ or /Criterion/. Both frameworks are easy to use and can serve as a good foundation for your tests. /Unity/ is particularly lightweight and simple, while /Criterion/ combines ease of use with more advanced features that you might want to leverage as your tests grow in complexity.

Let's focus on /Unity/ first, as it's one of the simplest to set up and use:

1. *Unity*:

   /Unity/ is easy to get started with and provides a straightforward approach to writing tests. Here’s a simple example:

   #+begin_src c
   #include "unity.h"

   void setUp(void) {
       // Set up code here
   }

   void tearDown(void) {
       // Clean up code here
   }

   void test_SampleTest(void) {
       TEST_ASSERT_EQUAL(1, 1);
   }

   int main(void) {
       UNITY_BEGIN();
       RUN_TEST(test_SampleTest);
       return UNITY_END();
   }
   #+end_src
   To get started with /Unity/, you'll need to download it from its GitHub repository and include the necessary files in your project.

2. *Criterion*:

   /Criterion/ is also beginner-friendly but has more features that you might find useful as your project evolves.

   Here’s a simple example for /Criterion/:

   #+begin_src c
   #include <criterion/criterion.h>

   Test(sample, sample_test) {
       cr_assert_eq(1, 1, "1 should be equal to 1");
   }
   #+end_src
   To get started with /Criterion/, you’ll need to install it (it’s usually available in most package managers) and link it with your project.

If you envision a growing need for more advanced testing capabilities in the near future, starting with /Criterion/ might save you some time switching frameworks later on. However, if simplicity and ease of initial setup are your top priorities, /Unity/ is an excellent choice.

Choose the one that best aligns with your current needs and growth expectations. You won't go wrong with either!

*** Does criterion support mocks?

Yes, /Criterion/ supports mocks, which can be very useful as your testing needs evolve. It provides a way to mock functions and verify interactions, making it a good choice if you anticipate needing more advanced features in the future.

Here’s a simple example demonstrating how you can use mocks in /Criterion/:

1. *Mocking functions*: You can mock functions to intercept calls and define specific behavior for your tests.

Here's an example of mocking a standard C library function:

#+begin_src c
#include <criterion/criterion.h>
#include <criterion/redirect.h>

int fake_function(const char *input) {
    cr_log_warn("Fake function called with input: %s\n", input);
    return 42; // return a predefined value
}

Test(sample, mock_function_test) {
    cr_redirect_stdout(); // redirect stdout to capture output

    // Inject the mock
    CR_DEFINE_FAKE(int, real_function, (const char *));
    real_function = fake_function;

    // Call the function in your test
    int result = real_function("test input");

    // Verify the result
    cr_assert_eq(result, 42, "Expected %d but got %d", 42, result);
}
#+end_src

This example demonstrates how you can define a fake function and use it in your test case by overriding the real function. The =cr_redirect_stdout= function is used to capture any print statements (for instance, if you were testing how logging behaves).

2. *Using Mocks for Custom Functions*: If you have custom functions that you'd like to mock, you can use a similar approach:

#+begin_src c
#include <criterion/criterion.h>

// Original Function
int add(int a, int b) {
    return a + b;
}

// Mock Function
int mock_add(int a, int b) {
    return a * b; // Change behavior for the sake of testing
}

Test(sample, custom_mock_test) {
    // Inject the mock
    CR_DEFINE_FAKE(int, add, (int, int));
    add = mock_add;

    // 6, result);
}
#+end_src

In this example, we mocked a simple =add= function to change its behavior within the test.

/Criterion/’s mocking capabilities make it a flexible and powerful framework, allowing you to start with simplistic tests and scale up to more complex scenarios involving mocks and other advanced features. This makes it a solid choice as you grow your testing suite!

*** Is criterion also suited for C++ projects?

While /Criterion/ is specifically designed for C projects and excels in that area, it can also be used in C++ projects, especially when your C++ code maintains C-like characteristics. However, for C++ projects, there are other frameworks more tailored to the language's features and idioms, such as Google Test or Catch2.

That said, if you have a mixed C/C++ project or prefer to use /Criterion/ in a C++ context, you can certainly do so. Here’s how you might set up a simple test in a C++ project using /Criterion/:

**** Example using /Criterion/ in a C++ project

1. Ensure your project is set up to compile with C++.

2. Write test cases using the /Criterion/ API within C++ source files (.cpp):

#+begin_src cpp
#include <criterion/criterion.h>

// Example C++ function
int add(int a, int b) {
    return a + b;
}

Test(sample_suite, sample_test) {
    cr_assert_eq(add(2, 3), 5, "Expected 2 + 3 to be 5");
}
#+end_src

3. Compile your project linking against the /Criterion/ library.

**** Compiling and Running

Here's an example Makefile snippet to compile a C++ project using /Criterion/:

#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++11 -Wall -Wextra
LDFLAGS := -lcriterion

SRCS := main.cpp
OBJS := $(SRCS:.cpp=.o)

all: test

test: $(OBJS)
	$(CXX) $(CXXFLAGS) -o $@ $^ $(LDFLAGS)

clean:
	rm -f $(OBJS) test

.PHONY: all clean
#+end_src

Run the =make= command to compile, and then execute the =./test= binary to run your test cases.

While /Criterion/ can handle C++ code, you might find that frameworks specially designed for C++ (like Google Test or Catch2) offer integrations and features that better match C++ paradigms, such as class testing, templates, and exception handling.

*Recommendation*: If your codebase is predominantly C++, consider shifting to a C++-specific testing framework. If your project is primarily in C with occasional C++ integration, /Criterion/ is a perfectly valid choice and can handle the C++ parts well.

***
*** May i use GoogleTest for testing C code?


Yes, you can use /GoogleTest/ to test C code! Although /GoogleTest/ is primarily designed for C++ projects, it can be adapted to test C code as well. You'll need to take a few steps to handle the linkage between C and C++ properly, but it's quite feasible.

Here's a simple way to set up /GoogleTest/ for testing a C function:

1. *Create a C function*:

   Save your C code in a .c file.

   #+begin_src c
   // my_code.c

   #include "my_code.h"

   int add(int a, int b) {
       return a + b;
   }
   #+end_src

2. *Create a header for your C function*:

   This ensures the function can be linked correctly in C++.

   #+begin_src c
   // my_code.h

   #ifndef MY_CODE_H
   #define MY_CODE_H

   #ifdef __cplusplus
   extern "C" {
   #endif

   int add(int a, int b);

   #ifdef __cplusplus
   }
   #endif

   #endif // MY_CODE_H
   #+end_src

3. *Create a GoogleTest case in a C++ file*:

   You will write your tests in C++ to utilize /GoogleTest/ while calling the C functions.

   #+begin_src cpp
   // test_my_code.cpp

   #include <gtest/gtest.h>
   #include "my_code.h"

   TEST(AdditionTest, HandlesPositiveValues) {
       EXPECT_EQ(add(2, 3), 5);
   }

   int main(int argc, char **argv) {
       ::testing::InitGoogleTest(&argc, argv);
       return RUN_ALL_TESTS();
   }
   #+end_src

4. *Compile your code linking both the C and C++ parts*:

   Here's how you might set up a Makefile to handle this:

   #+begin_src makefile
   CC := gcc
   CXX := g++
   CFLAGS := -Wall -Wextra -std=c99
   CXXFLAGS := -Wall -Wextra -std=c++11
   LDFLAGS := -lgtest -lgtest_main -pthread

   SRCS_C := my_code.c
   SRCS_CPP := test_my_code.cpp
   OBJS_C := $(SRCS_C:.c=.o)
   OBJS_CPP := $(SRCS_CPP:.cpp=.o)

   all: test

   test: $(OBJS_C) $(OBJS_CPP)
       $(CXX) -o $@ $^ $(LDFLAGS)

   %.o: %.c
       $(CC) $(CFLAGS) -c $< -o $@

   %.o: %.cpp
       $(CXX) $(CXXFLAGS) -c $< -o $@

   clean:
       rm -f $(OBJS_C) $(OBJS_CPP) test

   .PHONY: all clean
   #+end_src

5. *Run your tests*:

   Once everything is set up, compile and run your tests with:

   #+begin_src sh
   make
   ./test
   #+end_src

This approach allows you to leverage the robust features of /GoogleTest/ even for your C code, giving you a powerful framework right from the start.

Using /GoogleTest/ for C code can be useful if you anticipate transitioning to more C++ in the future or if you want to take advantage of /GoogleTest/'s advanced features even when working primarily in C.

*** Can you explain the header file in detail?

   #+begin_src c
   // my_code.h

   #ifndef MY_CODE_H
   #define MY_CODE_H

   #ifdef __cplusplus
   extern "C" {
   #endif

   int add(int a, int b);

   #ifdef __cplusplus
   }
   #endif

   #endif // MY_CODE_H
   #+end_src


Sure! Let's break down each part of the header file in detail:

#+begin_src c
// my_code.h
#+end_src

This line is the filename, indicating that this file contains function declarations and potentially definitions to be shared across different parts of your program.

#+begin_src c
#ifndef MY_CODE_H
#define MY_CODE_H
#+end_src

These lines are "include guards." Their purpose is to prevent multiple inclusions of the same header file, which can cause errors due to redefinitions. Here's how it works:

1. =#ifndef MY_CODE_H=: Checks if the macro =MY_CODE_H= is not defined.
2. =#define MY_CODE_H=: If the macro is not defined, it defines it. This way, the contents of the header file are included only once per compilation unit.

#+begin_src c
#ifdef __cplusplus
extern "C" {
#endif
#+end_src

These lines ensure compatibility with C++ compilers. They check if the code is being compiled with a C++ compiler (=__cplusplus= is defined by the C++ compiler). If so, the =extern "C"= block begins.

The =extern "C"= linkage specification tells the C++ compiler to use C linkage for the enclosed declarations. This prevents name mangling (which is the C++ method for handling function overloading) and allows the C++ compiler to correctly link with functions compiled using a C compiler.

#+begin_src c
int add(int a, int b);
#+end_src

This line declares the =add= function. It's a prototype telling the compiler about the function name, return type, and parameters. In this case, =add= takes two integers as arguments and returns an integer.

#+begin_src c
#ifdef __cplusplus
}
#endif
#+end_src

These lines close the =extern "C"= block, ending the section where the C linkage specifications apply.

#+begin_src c
#endif // MY_CODE_H
#+end_src

This line closes the include guard, ensuring that the contents of this header file are protected against multiple inclusions.

*** Complete Header File Explanation:

Here’s the complete header file with comments added for clarity:

#+begin_src c
// my_code.h

// Include guard: Prevents multiple inclusions of this header file
#ifndef MY_CODE_H
#define MY_CODE_H

// If using a C++ compiler, use C linkage for the following declarations
#ifdef __cplusplus
extern "C" {
#endif

// Function declaration: Adds two integers
int add(int a, int b);

// End the C linkage specification
#ifdef __cplusplus
}
#endif

// End of include guard
#endif // MY_CODE_H
#+end_src

By using these constructs, the header file ensures that:
1. It can be safely included multiple times without causing redefinition errors.
2. The declared functions can be used in both C and C++ programs, with proper linkage handling for C++ compilers.

***
*** Ok, I want to use gtest with make. I have a src/ directory, a obj/ directory, a bin/ directory and a tests/ directory. Can you give me an outline?

Absolutely! Here's an outline for setting up a /GoogleTest/ project with a typical directory structure and a Makefile to manage the build process. The directories are:

- src/: Source files for your application.
- obj/: Object files.
- bin/: Executable files.
- tests/: Test source files.

Assuming you have the following files:

- src/my_code.c: Your C source file.
- src/my_code.h: Your header file.
- tests/test_my_code.cpp: Your GoogleTest C++ test file.

Here’s how you can set up the project:

**** Directory Structure:

#+begin_src
project_root/
├─ src/
│  ├─ my_code.c
│  └─ my_code.h
├─ obj/
├─ bin/
├─ tests/
│  └─ test_my_code.cpp
├─ Makefile
#+end_src

**** Example =Makefile=:

#+begin_src makefile
# Compiler and flags
CC := gcc
CXX := g++
CFLAGS := -Wall -Wextra -std=c99
CXXFLAGS := -Wall -Wextra -std=c++11
LDFLAGS := -lgtest -lgtest_main -pthread

# Directories
SRC_DIR := src
OBJ_DIR := obj
BIN_DIR := bin
TESTS_DIR := tests

# Source files and object files
SRC_FILES := $(wildcard $(SRC_DIR)/*.c)
OBJ_FILES := $(SRC_FILES:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
TEST_FILES := $(wildcard $(TESTS_DIR)/*.cpp)
TEST_OBJ_FILES := $(TEST_FILES:$(TESTS_DIR)/%.cpp=$(OBJ_DIR)/%.o)

# Executable names
TARGET := $(BIN_DIR)/my_app
TEST_TARGET := $(BIN_DIR)/run_tests

.PHONY: all clean

all: $(TARGET) $(TEST_TARGET)

# Build the main application
$(TARGET): $(OBJ_FILES)
	$(CC) -o $@ $^

# Build the tests executable
$(TEST_TARGET): $(OBJ_FILES) $(TEST_OBJ_FILES)
	$(CXX) -o $@ $^ $(LDFLAGS)

# Compile C source files to object files
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(OBJ_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Compile C++ test files to object files
$(OBJ_DIR)/%.o: $(TESTS_DIR)/%.cpp
	@mkdir -p $(OBJ_DIR)
	$(CXX) $(CXXFLAGS) -c $< -o $@ 

# Clean up build files
clean:
	rm -rf $(OBJ_DIR)/*.o $(BIN_DIR)/*
#+end_src

**** Source and Test Files:

*src/my_code.c*:
#+begin_src c
#include "my_code.h"

int add(int a, int b) {
    return a + b;
}
#+end_src

*src/my_code.h*:
#+begin_src c
#ifndef MY_CODE_H
#define MY_CODE_H

#ifdef __cplusplus
extern "C" {
#endif

int add(int a, int b);

#ifdef __cplusplus
}
#endif

#endif // MY_CODE_H
#+end_src

*tests/test_my_code.cpp*:
#+begin_src cpp
#include <gtest/gtest.h>
#include "my_code.h"

TEST(AdditionTest, HandlesPositiveValues) {
    EXPECT_EQ(add(2, 3), 5);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
#+end_src

**** Steps to Build and Run:
1. Navigate to the root directory of your project.
2. Run =make= to compile the project. This will create the object files in the /obj/* directory and the executables in the /bin/* directory.
3. Run the main application using =./bin/my_app= if there is a main application logic.
4. Run the tests using =./bin/run_tests=.

This setup provides a clean structure for your project, separating source files, object files, and binaries, and allows you to easily manage your build process with =make=.

*** I think that gtest requires C++14

You're correct! /GoogleTest/ requires at least C++14 for compiling. Let's update the Makefile to reflect this, and ensure that everything is configured appropriately.

Here's the updated Makefile:

#+begin_src makefile
# Compiler and flags
CC := gcc
CXX := g++
CFLAGS := -Wall -Wextra -std=c99
CXXFLAGS := -Wall -Wextra -std=c++14
LDFLAGS := -lgtest -lgtest_main -pthread

# Directories
SRC_DIR := src
OBJ_DIR := obj
BIN_DIR := bin
TESTS_DIR := tests

# Source files and object files
SRC_FILES := $(wildcard $(SRC_DIR)/*.c)
OBJ_FILES := $(SRC_FILES:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
TEST_FILES := $(wildcard $(TESTS_DIR)/*.cpp)
TEST_OBJ_FILES := $(TEST_FILES:$(TESTS_DIR)/%.cpp=$(OBJ_DIR)/%.o)

# Executable names
TARGET := $(BIN_DIR)/my_app
TEST_TARGET := $(BIN_DIR)/run_tests

.PHONY: all clean

all: $(TARGET) $(TEST_TARGET)

# Build the main application
$(TARGET): $(OBJ_FILES)
	$(CC) -o $@ $^

# Build the tests executable
$(TEST_TARGET): $(OBJ_FILES) $(TEST_OBJ_FILES)
	$(CXX) -o $@ $^ $(LDFLAGS)

# Compile C source files to object files
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(OBJ_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Compile C++ test files to object files
$(OBJ_DIR)/%.o: $(TESTS_DIR)/%.cpp
	@mkdir -p $(OBJ_DIR)
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Clean up build files
clean:
	rm -rf $(OBJ_DIR)/*.o $(BIN_DIR)/*
#+end_src

This updated Makefile ensures that the C++14 standard is used when compiling your test files.

**** Directory Structure

Here's the directory structure for clarity:

#+begin_src
project_root/
├── src/
│   ├── my_code.c
│   └── my_code.h
├── obj/
├── bin/
├── tests/
│   └── test_my_code.cpp
├── Makefile
#+end_src

**** Source and Test Files

***** src/my_code.c
#+begin_src c
#include "my_code.h"

int add(int a, int b) {
    return a + b;
}
#+end_src

***** src/my_code.h
#+begin_src c
#ifndef MY_CODE_H
#define MY_CODE_H

#ifdef __cplusplus
extern "C" {
#endif

int add(int a, int b);

#ifdef __cplusplus
}
#endif

#endif // MY_CODE_H
#+end_src

***** tests/test_my_code.cpp
#+begin_src cpp
#include <gtest/gtest.h>
#include "my_code.h"

TEST(AdditionTest, HandlesPositiveValues) {
    EXPECT_EQ(add(2, 3), 5);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
#+end_src

**** Steps to Build and Run

1. Navigate to the root directory of your project.
2. Run =make= to compile the project. This will create the object files in the =obj/= directory and the executables in the =bin/= directory.
3. Run the main application using =./bin/my_app= if there is a main application logic.
4. Run the tests using =./bin/run_tests=.

This should give you a well-organized project structure, using =make= to handle building your C and C++ code along with your tests using /GoogleTest/.
*** What are the LDFLAGS for?

The =LDFLAGS= variable in a Makefile is used to specify options to the linker, the program that combines object files into an executable or library. These options can include libraries to link against, library search paths, and various other linker-specific flags.

In the context of the Makefile you are working with, the =LDFLAGS= are:

#+begin_src makefile
LDFLAGS := -lgtest -lgtest_main -pthread
#+end_src

Here’s a breakdown of what each flag does:

1. =-lgtest=: This tells the linker to link against the GoogleTest library (=libgtest.a= or =libgtest.so=). GoogleTest provides functions and macros to support unit testing in C++.

2. =-lgtest_main=: This tells the linker to link against the GoogleTest main library (=libgtest_main.a= or =libgtest_main.so=). The =gtest_main= library provides a default main function to initialize GoogleTest and run your tests. By linking against this library, you don't need to define your own =main= function unless you need custom initialization.

3. =-pthread=: This tells the linker to link against the POSIX thread library. GoogleTest uses multithreading internally, so this flag is necessary on systems where the threading library needs to be explicitly linked (like many Unix-like operating systems).

By setting =LDFLAGS= to include these options, you ensure that when the linker runs to create your test executable, it correctly links against GoogleTest and the necessary threading library, allowing your tests to compile and run correctly.

*** explain briefly the following: SRC_FILES := $(wildcard $(SRC_DIR)/*.c)


Sure! Here's a brief explanation:

#+begin_src makefile
SRC_FILES := $(wildcard $(SRC_DIR)/*.c)
#+end_src

This line in the Makefile uses the =wildcard= function to generate a list of all the C source files (=*.c=) in the =SRC_DIR= directory and assigns this list to the =SRC_FILES= variable.

*Explanation:*

- =wildcard $(SRC_DIR)/*.c=: The =wildcard= function generates a list of filenames matching the given pattern. Here, =$(SRC_DIR)/*.c= matches all files with a =.c= extension in the directory specified by =SRC_DIR=.
- =SRC_FILES :==: The =:== operator is used to assign the result of the =wildcard= function to the =SRC_FILES= variable. This means =SRC_FILES= will hold a space-separated list of all =.c= files found in the =SRC_DIR= directory.

This enables the Makefile to dynamically include all C source files in the specified directory when building the project.

***
